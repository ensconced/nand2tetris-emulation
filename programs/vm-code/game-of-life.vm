// GAME OF LIFE

// static 0 is timer
// static 1 is prevkey
// static 2 is screen pointer
// static 3 is xoffset
// static 4 is yoffset
// static 5 is outertimer
// static 6 is compact_representation_offset

function Sys.init 1
  // initialize timer
  push constant 0
  pop static 0

  // initialize outertimer
  push constant 0
  pop static 5

  // initialize keyboard
  push constant 24576
  pop pointer 1

  // initialize xoffset
  push constant 0
  pop static 3

  // initialize yoffset
  push constant 0
  pop static 4

  // initialize compact representation offset
  push constant 0
  pop static 6

  label start
    call increment_timers 0
    pop constant 0 // discard return value

    call is_frame 0
    if-goto call_handle_frame
    goto after_call_handle_frame

    label call_handle_frame
    call handle_frame 0
    pop constant 0
    label after_call_handle_frame

    call key_changed 0
    if-goto call_handle_key_change
    goto start

    label call_handle_key_change
    call handle_key_change 0
    pop constant 0
    goto start

function handle_key_change 0
  // update_compact_representation
  push static 0
  call update_compact_representation 1
  pop constant 0

  // compact_representation_offset = (compact_representation_offset + 1) % 32
  push static 6
  push constant 1
  add
  push constant 31
  and
  pop static 6

  call draw_from_compact_representation 0
  return

function update_compact_representation 0
  // set THIS
  push static 6 // compact_representation_offset
  push constant 2048 // base of compact representation
  add
  pop pointer 0

  push argument 0 // value
  pop this 0

  push constant 0
  return

function draw_from_compact_representation 1
  push constant 16384
  pop static 2

  push constant 2048
  pop local 0 // base of row within compact representation

  label start_loop
    push local 0
    push constant 2080
    eq
    if-goto end_loop

    push local 0
    call draw_row_from_compact_representation 1
    pop constant 0

    push static 2
    push constant 512
    add
    pop static 2

    push local 0
    push constant 2
    add
    pop local 0

    goto start_loop
    label end_loop

  push constant 0
  return

function draw_row_from_compact_representation 1
  push static 2
  pop local 0

  push argument 0
  call draw_half_row 1
  pop constant 0

  push static 2
  push constant 16
  add
  pop static 2

  push argument 0
  push constant 1
  add
  call draw_half_row 1
  pop constant 0

  // rewind screen pointer
  push local 0
  pop static 2

  push constant 0
  return

function draw_half_row 2
  push static 2
  pop local 1

  push argument 0
  pop pointer 0

  push constant 1
  pop local 0 // mask

  label start_loop
    push local 0
    push constant 0
    eq
    if-goto end_loop

    push this 0
    push local 0
    and
    push local 0
    eq
    call draw_square 1
    pop constant 0

    push static 2
    push constant 1
    add
    pop static 2

    push local 0
    push local 0
    add
    pop local 0

    goto start_loop
    label end_loop

  // rewind screen pointer
  push local 1
  pop static 2

  push constant 0
  return

// draw square, without moving screen pointer
function draw_square 1
  push static 2
  pop pointer 0

  push constant 0
  pop local 0
  label start_loop
    push local 0
    push constant 16
    eq
    if-goto end_loop

    push argument 0
    pop this 0

    push pointer 0
    push constant 32
    add
    pop pointer 0

    push local 0
    push constant 1
    add
    pop local 0

    goto start_loop
    label end_loop

  push constant 0
  return

function key_changed 1
  // local 0 is currentkey

  // get currentkey
  push constant 24576
  pop pointer 1
  push that 0
  pop local 0

  push static 1
  push local 0
  eq
  not
  if-goto did_change
  goto did_not_change

  label did_change
  push local 0
  pop static 1
  // return true
  push constant 0
  not
  return

  label did_not_change
  // return false
  push constant 0
  return

function increment_timers 0
  push static 0
  push constant 1
  add
  pop static 0

  push static 0
  push constant 0
  eq
  if-goto increment_outer_timer
  push constant 0
  return

  label increment_outer_timer
  push static 5
  push constant 1
  pop static 5

  push static 5
  push constant 5
  eq
  if-goto zero_outer_timer
  push constant 0
  return

  label zero_outer_timer
  push constant 0
  pop static 5

  // we have to return something
  push constant 0
  return

function is_frame 0
  push static 5
  push constant 0
  eq
  return

function handle_frame 4
  // point THIS to current frame buffer
  push constant 2048
  pop pointer 0

  // point THAT to next frame buffer
  push constant 2080
  pop pointer 1

  push constant 0
  pop local 0 // wordidx

  label start_loop
    push local 0 // wordidx
    push constant 32
    eq
    if-goto end_loop

    push constant 0
    pop local 1 // bitidx

    push constant 0
    pop local 2 // word

    push constant 1
    pop local 3 // mask

    label start_inner_loop
      push local 1 // bitidx
      push constant 16
      eq
      if-goto end_inner_loop

      push local 0 // wordidx
      push local 1 // bitidx
      call get_next_state 2
      push local 3 // mask
      and
      push local 2 // word
      and
      pop local 2 // word

      // shift mask
      push local 3
      push local 3
      add
      pop local 3

      // bitidx++
      push local 1
      push constant 1
      add
      pop local 1
      goto start_inner_loop
      label end_inner_loop

    push local 2 // word
    pop that 0

    push pointer 1
    push constant 1
    add
    pop pointer 1

    push local 0 // wordidx
    push constant 1
    add
    pop local 0
    goto start_loop
    label end_loop

  call copy_next_buffer 0
  pop constant 0

  call draw_from_compact_representation 0
  return

function copy_next_buffer 0
  push constant 2048
  pop pointer 0

  push constant 2080
  pop pointer 1

  label start_loop
    push pointer 0
    push constant 2080
    eq
    if-goto end_loop

    push that 0
    pop this 0

    push pointer 0
    push constant 1
    add
    pop pointer 0

    push pointer 1
    push constant 1
    add
    pop pointer 1

    goto start_loop
    label end_loop

  push constant 0
  return

function left 0
  push constant 2112
  pop pointer 0

  push argument 1 // bitidx
  push constant 15
  eq
  if-goto call_handle_left_edgecase

  push argument 0 // wordidx
  pop this 0

  push argument 1 // bitidx
  push constant 1
  add
  pop this 1

  push constant 0
  return

  label call_handle_left_edgecase
  push argument 0
  push argument 1
  call left_edgecase 2
  return

function left_edgecase 0
  push constant 2112
  pop pointer 0

  push constant 0
  pop this 1

  push argument 0 // wordidx
  call is_even 1
  if-goto handle_even_wordidx
  push argument 0
  push constant 1
  sub
  pop this 0

  push constant 0
  return

  label handle_even_wordidx
  push argument 0
  push constant 1
  add
  pop this 0

  push constant 0
  return


function right 0
  push constant 2112
  pop pointer 0

  push argument 1 // bitidx
  push constant 0
  eq
  if-goto handle_right_edgecase
  push argument 0
  pop this 0

  push argument 1
  push constant 1
  sub
  pop this 1

  push constant 0
  return

  label handle_right_edgecase
  push argument 0
  push argument 1
  call right_edgecase 2
  return

function right_edgecase 0
  push constant 2112
  pop pointer 0

  push constant 15
  pop this 1

  push argument 0 // wordidx
  call is_even 1
  if-goto handle_even_wordidx

  push argument 0
  push constant 1
  sub
  pop this 0

  push constant 0
  return

  label handle_even_wordidx
  push argument 0
  push constant 1
  pop this 0


  push constant 0
  return

function up 0
  push constant 2112
  pop pointer 0

  push argument 0
  push constant 30
  add
  push constant 31
  and
  pop this 0

  push argument 1
  pop this 1

  push constant 0
  return

function down 0
  push constant 2112
  pop pointer 0

  push argument 0
  push constant 2
  add
  push constant 31
  and
  pop this 0

  push argument 1
  pop this 1

  push constant 0
  return

function up_left 0
  push constant 2112
  pop pointer 0

  push argument 0
  push argument 1
  call left 2

  push this 0
  push this 1
  call up 2

  push constant 0
  return

function up_right 0
  push constant 2112
  pop pointer 0

  push argument 0
  push argument 1
  call right 2

  push this 0
  push this 1
  call up 2

  push constant 0
  return

function down_right 0
  push constant 2112
  pop pointer 0

  push argument 0
  push argument 1
  call right 2

  push this 0
  push this 1
  call down 2

  push constant 0
  return

function down_left 0
  push constant 2112
  pop pointer 0

  push argument 0
  push argument 1
  call left 2

  push this 0
  push this 1
  call down 2

  push constant 0
  return

function read_value 2
  // generate mask
  push constant 1
  pop local 0 // mask

  push constant 0
  pop local 1 // counter
  label start_loop
    push argument 1 // bitidx
    push local 1
    eq
    if-goto end_loop

    push local 0
    push local 0
    add
    pop local 0

    push local 1
    push constant 1
    add
    pop local 1

    goto start_loop
    label end_loop

  push constant 2048
  push argument 0
  add
  pop pointer 0
  push this 0 // value
  push local 0 // mask
  and
  push local 0
  eq
  return

function count_alive_neighbours 1
  push constant 2112
  pop pointer 0

  push constant 0
  pop local 0 // sum

  push argument 0
  push argument 1
  call up 2
  pop constant 0
  push this 0
  push this 1
  call read_value 2
  if-goto include_up
  goto end_up
  label include_up
  push local 0
  push constant 1
  add
  pop local 0
  label end_up

  push argument 0
  push argument 1
  call up_right 2
  pop constant 0
  push this 0
  push this 1
  call read_value 2
  if-goto include_up_right
  goto end_up_right
  label include_up_right
  push local 0
  push constant 1
  add
  pop local 0
  label end_up_right

  push argument 0
  push argument 1
  call right 2
  pop constant 0
  push this 0
  push this 1
  call read_value 2
  if-goto include_right
  goto end_up_right
  label include_right
  push local 0
  push constant 1
  add
  pop local 0
  label end_right

  push argument 0
  push argument 1
  call down_right 2
  pop constant 0
  push this 0
  push this 1
  call read_value 2
  if-goto include_down_right
  goto end_down_right
  label include_down_right
  push local 0
  push constant 1
  add
  pop local 0
  label end_down_right

  push argument 0
  push argument 1
  call down 2
  pop constant 0
  push this 0
  push this 1
  call read_value 2
  if-goto include_down
  goto end_down
  label include_down
  push local 0
  push constant 1
  add
  pop local 0
  label end_down

  push argument 0
  push argument 1
  call down_left 2
  pop constant 0
  push this 0
  push this 1
  call read_value 2
  if-goto include_down_left
  goto end_down_left
  label include_down_left
  push local 0
  push constant 1
  add
  pop local 0
  label end_down_left

  push argument 0
  push argument 1
  call left 2
  pop constant 0
  push this 0
  push this 1
  call read_value 2
  if-goto include_left
  goto end_left
  label include_left
  push local 0
  push constant 1
  add
  pop local 0
  label end_left

  push argument 0
  push argument 1
  call up_left 2
  pop constant 0
  push this 0
  push this 1
  call read_value 2
  if-goto include_up_left
  goto end_up_left
  label include_up_left
  push local 0
  push constant 1
  add
  pop local 0
  label end_up_left

  push local 0
  return

function is_even 0
  push argument 0
  push constant 1
  and
  push constant 1
  eq
  not
  return

function get_next_state 2
  push argument 0
  push argument 1
  call count_alive_neighbours 2
  pop local 0 // live_neighbour_count

  push argument 0
  push argument 1
  call read_value 2
  pop local 1 // current_state

  push local 1
  push constant 0
  not
  eq
  if-goto handle_living_cell

  // handle dead cell
  push local 0
  push constant 3
  eq
  if-goto live

  // stay dead
  push constant 0
  return

  label handle_living_cell
  push local 0
  push constant 2
  eq
  if-goto live
  push local 0
  push constant 3
  if-goto live
  // die
  push constant 0
  return

  label live
    push constant 0
    not
    return