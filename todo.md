# call graph analysis

Initial refactoring - need to add separate desugaring phase, so that stuff like multiplication operators and division is turned into proper function calls.
This will allow for constructing the call graph based on just the parsed desugared jack code, either in its own phase or as part of the jack compiler codegen phase.

gather information on functions during jack compilation codegen phase:

- name: String
- arg_count: usize
- local_count: usize
- returns_void: boolean

then in vm compilation phase, augment with:

- calls
- called_by

This information should allow a number of optimisations:

- dead code elimination
- function call/return optimisation (by minimising saved/restored frame pointers)
- eliminate unnecessary pushing/popping of return values
- only include glyphs_asm if glyphs class is used

same of both cases - essentially a call graph

- drawRectangle
- create web IO implementation for web debugger
- make code panels draggable/collapsible
- use test methods for stepping through in emulator?
- use this to debug int printing issue
- do compiling in browser with webapp, using wasm-bindgen to get result with sourcemap - then can use types generated by wasm-bindgen - no need for ts_rs?
- read docs on wasm-bindgen https://rustwasm.github.io/docs/wasm-bindgen/examples/index.html
- "realtime play" - wil require windowing code-panels to improve perf
- show contextual jack node
- include linting and tsc in test suite

## perf/code-size optimisations

- identidcal code folding - automatic extraction of subroutines
- don't unnecessarily zero-out locals in jack code
- use an even smaller font e.g. this 5x5 px one https://www.dafont.com/5x5.font (and caps only?)
- peephole optimisation of vm code

### emulator enhancements

- report stack overflows etc
- add stepping ability
  - step line of jack code
  - step line of vm code
  - step asm instruction

### refactoring

- make error handling and reporting more consistent in parsers
- maybe get rid of clap and parse cli args myself

# TODO

- write full stdlib
- implement vector module
- add SCREEN and GLYPHS variable for use in jack code
- allow use of e.g. var int[4] foo; to declare fixed-length arrays to be allocated in static section, or on stack. this could make the code in Memory.jack much neater
- figure out limits of current algo for two's complement multiplication - is there a simple failing example for a small negative number?
- booth's algo? or...read this: https://pages.cs.wisc.edu/~markhill/cs354/Fall2008/beyond354/int.mult.html ?
- check arg count equals param count? might be difficult - would need to look across classes sometimes...

### jack extras

- for loops
- pointers
- rudimentary typechecking? might be tricky...would need to allow some coercions - e.g. obj to int for Memory.dealloc, array to obj for constructors.
- break/continue

### programs

- pong
- mandelbrot
- tetris
- game of life
- asteroids
- snake
- game selector

### hardware

- add timer?
- add another hardware register?
- bitshift - this would be really helpful...
- floating point?
- multiplication / division?
- ethernet...
- graphics: fix flickering by assigning a "don't draw" register which programs can use to flag when frame buffer is in an inconsistent state, and which the computer will read to decide whether or not to actually refresh the screen. will need to figure out how to make this work on the fpga too!
